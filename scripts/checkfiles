#!/usr/bin/env python3

import os
import sys
import re
import argparse
import pprint
import subprocess
import shlex
import yaml
import fnmatch
from pathlib import Path, PurePath

CONFIG_FILE = '.checkfiles.yml'

def err_msg(*lines, **kwargs):
    print(*lines,
          sep=kwargs.get('sep','\n'),
          file=kwargs.get('file',sys.stderr))

def debug(tag, text):
    global options
    if options.verbose:
        print("# {:10}: {}".format(tag,text))
        pass
    pass

def quit(*lines, **kwargs):
    err_msg(*lines, **kwargs)
    sys.exit(-1)

def exception_msg():
    return str(sys.exc_info()[1])

def shell_quote(cmd_as_list):
    return " ".join([shlex.quote(a) for a in cmd_as_list])

def parse_command_line(cmd, args):
    parser = argparse.ArgumentParser(
        prog=cmd,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False,
        description="""
Recursively traverse each path listed on the command line, and run Linux
kernel checkpatch tool on each C source file found.
""",
    )

    long_help = """
Configuration files:

  Each directory can optionally contian a YAML-formatted file named
  ".checkfiles.yml" to customize how the directory and its files are
  processed.  The configuration file allows you to:

    - skip the directory and all files under it
    - skip specific files in the directory
    - ignore specific checkpatch warnings on a file-by-file basis

  Example configuration file:

    $ cat source/utils/.checkfiles.yml:
    prune: false
    files:
      frog.h:    {args: ["--ignore", "NEW_TYPEDEFS"]}
      lizard.h:  {args: ["--ignore", "COMPLEX_MACRO,INLINE,ASSIGN_IN_IF"]}
      toad.h:    {skip: true}

  In the above example:
    - if 'prune' were set to 'true' then everything under 'source/utils' would be skipped.
    - toad.h is skipped
    - one warning (NEW_TYPEDEFS) is ignored in file frog.h
    - three warnings are ignored in file lizard.h
    - all other files source/utils/*.[ch] are processed normally

Examples:
  Use with robopatch:
    checkfiles -o raw components/platform > log
    robopatch.pl < log
  Use with emacs 'next-error' command which relies on grep-like output:
    M-x compile: checkfiles -o grep components/platform
"""


    parser.add_argument(
        "-h",
        dest="help",
        help="show usage summary",
        action="store_true")

    parser.add_argument(
        "--help",
        dest="help_long",
        help="show detailed help",
        action="store_true")

    parser.add_argument(
        "--build",
        help="run checkfiles in build mode",
        action="store",
        required=False)

    parser.add_argument(
        "-a",
        dest="all",
        help="check all files (not just *.[ch] files)",
        action="store_true")

    parser.add_argument(
        "-n",
        dest="dryrun",
        help="show commands w/o executing",
        action="store_true")

    parser.add_argument(
        "-v",
        dest="verbose",
        help="be verbose",
        action="store_true")

    parser.add_argument(
        "-l",
        dest="list",
        help="list files that would be processed (do not actually run checks)",
        action="store_true")

    parser.add_argument(
        "-o",
        dest="output_style",
        default='grep',
        choices=['grep', 'raw'],
        help="set output style (default=grep)")

    parser.add_argument(
        "--no-config-files",
        dest="no_config_files",
        help="ignore "+CONFIG_FILE+" configuration files",
        action="store_true")

    # works with: -- file1 file2 ...
    parser.add_argument(
        dest="paths",
        nargs="*",
        help="files and/or directories to process")

    options = parser.parse_args(args)
    if options.help:
        parser.print_help()
        sys.exit(0)
        pass
    if options.help_long:
        parser.print_help()
        print(long_help)
        sys.exit(0);
        pass

    return options

def run_cmd(cmd, dryrun=False, timeout=10):
    if dryrun:
        sys.stdout.write(shell_quote(cmd))
        sys.stdout.write('\n')
        rc = 0
    else:
        try:
            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                # next line does this: 2>&1
                stderr=subprocess.STDOUT,
                universal_newlines=True)

            for line in proc.stdout:
                sys.stdout.write(line)
                sys.stdout.flush()
                pass
            rc = proc.wait(timeout=timeout)
        except:
            quit("Exception: {msg}".format(msg=exception_msg()))
    return rc

def path_matches(path, pattern_list):
    for pattern in pattern_list:
        if fnmatch.fnmatch(path, pattern):
            return True
        pass
    return False

def read_cfg(dirpath):
    cfg = dict()
    if not options.no_config_files:
        cfg_file = os.path.join(dirpath,CONFIG_FILE)
        if os.path.isfile(cfg_file):
            debug("readcfg", cfg_file)
            try:
                fh = open(cfg_file,'r')
            except:
                quit('Cannot open config file: ' + cfg_file, exception_msg())
                pass
            try:
                cfg = yaml.load(fh)
            except:
                quit('Cannot parse config file: ' + cfg_file,
                     'Must be a YAML file.', exception_msg())
                fh.close()
                pass
            pass
        pass
    return cfg

def is_pruned_by_cfg(tree_root, start_dir):
    root_dir = PurePath(tree_root)
    cur_dir  = PurePath(start_dir)

    while True:
        cfg = read_cfg(str(cur_dir))
        if len(cfg) > 0 and cfg_prune(cfg):
            return True
        if cur_dir == root_dir or str(cur_dir) == '.':
            return False
        else:
            cur_dir = cur_dir.parent

# Example yaml syntax:
#
#   prune: true
#   files:
#    foo.c: {args: [--ignore, "XX,YYY,ZZ"]}
#    bar.h: {skip: true}

def cfg_get(cfg, filename, attr, dflt):
    d, f = os.path.split(filename)
    if cfg and ('files' in cfg):
        info = cfg['files'].get(f,False)
        if info:
            return info.get(attr,dflt)
        pass
    return dflt

def cfg_skip(cfg, filename):
    return cfg_get(cfg, filename, 'skip', False)

def cfg_args(cfg, filename):
    return cfg_get(cfg, filename, 'args', [])

def cfg_prune(cfg):
    return cfg and ('prune' in cfg) and (cfg['prune'] == True)

################################################################


def run_checkpatch(cfg, patterns, filename):
    global options
    global checkpatch_style_args
    if os.path.islink(filename):
        debug('skip-symlink', filename)
        return 0
    if cfg_skip(cfg, filename):
        debug("skip-cfg", filename)
        return 0
    run = len(patterns) == 0 or path_matches(filename, patterns)
    if not run:
        debug("skip-pat", filename)
        return 0
    if options.list:
        print(filename)
        return 0
    return run_cmd(
        ['scripts/checkpatch.pl', '--ignore', 'SPLIT_STRING' ]
        + checkpatch_style_args
        + cfg_args(cfg, filename)
        + [ '-f', filename ],
        options.dryrun)

def walk_tree_checkfiles(pathlist, patterns):

    status = 0

    # check that each input path exists
    for path in pathlist:
        if not (os.path.isfile(path) or os.path.isdir(path)):
            quit("No such directory or file: {}".format(path))
            pass
        pass

    cfg_dir = None
    cfg = None

    for path in pathlist:
        if os.path.isfile(path):
            debug("cmdline", path)
            d, f = os.path.split(path)
            if options.build != None:
                if d != '' and is_pruned_by_cfg(options.build, d):
                    continue
            cfg = read_cfg(d)
            rc = run_checkpatch(cfg, patterns, path)
            if rc != 0:
                status = rc
                pass
        elif os.path.isdir(path):
            debug('cmdline', path)
            for (dirpath, dirnames, filenames) in os.walk(path):
                cfg = read_cfg(dirpath)
                if cfg_prune(cfg) or dirpath == ".git" or re.search('/.git$',dirpath):
                    debug('prune', dirpath)
                    # must update dirnames to prevent os.walk from recursing
                    dirnames[:] = []
                    filenames[:] = []
                else:
                    debug('dir', dirpath)
                    for filename in filenames:
                        rc = run_checkpatch(cfg, patterns, os.path.join(dirpath,filename))
                        if rc != 0:
                            status = rc
                            pass
                        pass
                    pass
                pass
            pass
        else:
            debug('skip(!file)', path)
            pass
        pass
    return status

def main(args):

    global options
    global checkpatch_style_args

    cmd = os.path.basename(__file__)
    options = parse_command_line(cmd, args[1:])

    #pprint.pprint(options)

    if len(options.paths) == 0:
        options.paths=['.']
        pass

    if options.output_style == 'raw':
        checkpatch_style_args = []
    elif options.output_style == 'grep':
        checkpatch_style_args = ['--no-tree', '-q', '--show-types', '--emacs', '--no-summary']
    else:
        quit("unsupported output style: "+options.output_style)
        pass

    return walk_tree_checkfiles(options.paths, [] if options.all else ['*.[ch]'])

if __name__ == "__main__":
    rc = main(sys.argv)
    sys.exit(rc)
