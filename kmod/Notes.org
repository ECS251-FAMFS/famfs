
TODO

* Semi-working functionality
** tagfs fsck
** mkfs.tagfs <dev>

* Testing plans
** TODO test files in non-root directory
and complex paths...
** TODO test filling up a tagfs file system
Need some intelligence to figure out when a create should fail based on size
of the FS.

* Known bugs
** DONE tagfs fsck: should fail by dev when mounted
Should be able to accomplish this via exclusive open in the driver...?
Fixed in tagfs_lib.c:tagfs_fsck, which new checks if mounted if invoked
by device.
** DONE tagfs fsck: sees empty log via /dev/pmem0
This worries me a bit. tagfs logplay via the file interface sees log entries, but
when the log is mmapped via /dev/pmem0, the log looks legit but empty. WTF?!
OK: this behavior happens when the file system is mounted and the log gets accessed
via the pmem device rather than the log file. Yeah, same memory, differnet method and
result. Solution: don't allow fsck via blkdev while the FS is mounted (which is a normal
limitation)
** DONE fsck via the meta files (rather than via pmem device) segfaults
If pass in a mount point or tagfs path, fsck now finds the meta files, but it
segfaults when checking the superblock magic #, even though in gdb I can dup the
contents of the superblock. Weird...
Solution: for some reason this didn't work via mmap (segfault when dereferencing
sb-> or logp-> even though gdb could dereference them. But allocating space and doing
a posix read into it solves that problem.
** TODO the 'tagfs creat' invocations in test0.sh have 000 permissions
...even though that's not the mode they're created under.
But 'tagfs cp' seems to get it right. Should be an easy fix...
** DONE tagfs creat: manually creating a cross-linked-file fails
File has no extents, is 0 size, and does not get unlinked
see test_corruption0.sh
Dropped manual extents. Just use clone instead.
** DONE tagfs creat: extents out of order when creating with manual extents
When I create a zero-based extent followed by a non-zero-based extent, I see them
out of order in getmap
Moot now that manual extents are dropped. (use clone instead)
** TODO linux "cmp" comparisons fail even when "tagfs verify" succeeds
There is something wrong with posix read. tagfs verify uses mmap, and verifies the
file againsts same-seed data.
** TODO tagfs fsck: does not detect cloned files
Now it returns the error count
Hmm: I saw it work, but it's failing with the current test2.sh.
Answer: that was almost certainly because fsck accessed /dev/pmem0 while the FS
was mounted, which somehow saw a stale log.
** DONE tagfs creat: mode is all 000
Looks like the mode string passed into open/creat is not 000


* Tests


* Missing functionality
** DONE Create log entry when allocating/creating a file
** DONE play log into file system
'tagfs logplay <mpt>'
** TODO un-tar into file system
** DONE Populate log
** DONE nop ioctl to verify that a file is in a tagfs fs
** TODO mkfs should fail if the device is not larger than the superblock + log
** TODO mkfs should make the log smaller if device is small?
** TODO Need a logplay variant that finds files that don't match logged size

* Needed for testability
** DONE create files of arbitrary sizes
tagfs creat -s <size>
** TODO create files with arbitrary extent lists and warn if extent conflicts
tagfs creat -n 2 --offset 0 --length 0x200000 --offset 0x400000 --length 0x200000

** DONE randomize file content based on supplied key (so files can be verified)
tagfs write -s <seed> -r <file>
** DONE Verify file contents
tagfs verify
** TODO tool to write/read/verify flexibly with both mmap and posix write/read
** TODO Read log and build bitmap, detecting duplicate memory references
** TODO intentional creation of duplicate memory references (alloc with specific extents)

* Add fs parameters
** DONE primary dax dev

* TODO Integrate wtih googletest and automate baseline set of tests
* TODO Debug "tagfs cp" cli functionality
* DONE Need uuid_gen() function in tagfs_lib
* TODO How will the kernel module read/access the superblock and log?
The superblock has the list of dax devices. The primary superblock has the TAGFS_PRIMARY_SB
flag set.

sb->ts_devlist is only valid on the primary superblock.

Each device has a uuid in its superblock - that will be an invariant way to reference
devices. Reference can be by index into teh ts_devlist[] on the primary superblock,
and the tagfs_daxdev needs the uuid for each device.
* TODO Create file ioctl must inherit dax device from superblock (if there is only one)
Oof, this requires a persistent mmap of the superblock and log from the in-memory sb. Hmm.
* TODO generate some proper mmap test cases
* TODO generate proper buffered I/O test cases
* TODO Generate tools for a recursive copy into tagfs file system
* DONE top level makefile that builds everything
* TODO Debug accessing dax device without block device
* TODO Study what happens when tagfs file is "of" for dd
The file gets truncated to zero-length, but then no writing happens

* DONE Rename ioctl #defines (s/MCIOC/TAGFSIOC/)

* DONE Superblock needs a UUID
* TODO Each file creation log entry needs a UUID (i.e. a file UUID)

* Design and implement MVP allocator
** DONE Generate a hidden allocation log file
Format: superblock, allocation log, superblock crc
Superblock: magic #, format version, offset to start of log, offset to next free log space
Each log entry: relpath, ext list, size, crc
Log entry types: file allocation, host access

* Test coverage


** interesting Idea:
*** Append-only allocation log
Only used by owner; can make allocations durable long before files get committed.
And allocations can be freed prior to file commit.

Issue: can I guarantee freeing of space for uncommitted files? If files have UUIDs and
allocation entries reference the file UUID, we can scan the main log and the allocation log and
free any allocations that reference UUIDs that are not assoociated with files. File creation
would have to be totally embargoed during this process.

*** Main log gets file creation entries when committed


** DONE Scan log and create allocation bitmap
All allocations work this way now (except the explicit ones via tagfs creat)
** TODO Scan all files and create allocation bitmap
Do this by scanning files rather than scanning log. Maybe even compare to log-based
bitmap

* Kernel fs features
** DONE decouple size from extent list
i.e. size can be <= extent list length
** TODO Dump the user-space file metadata (for cloning)
This will return a tagfs_ioc_map and an array of tagfs_user_extent structs
(might be 2 ioctls, one for tagfs_ioc_map - which will indicate how many extents - and a
second for the array of extents)
** TODO dump the xarray of which pages are currently populated
This is a derivative of csnoop, though the xarray conversion may change it.

* libtagfs
** TODO tagfs_create
- Create file in <mount_pt>/.tmp
- Set allocation and file size
- Mv to intended path
** DONE get size of pmem block device
** TODO Get size of dax character device
Done but need to test
** TODO Get device size regardless of type
Done but char device not tested yet
** TODO tagfs_setmode
** TODO tagfs_clone
Create another file referencing the same data. This should cause an fsck error, because
fsck will notice allocated blocks that are referenced by more than one file.

* Tagfs cli
** TODO tagfs fsck: check for double allocations and return err if there are errs
This can be marked done when there is a test.
This was working, but now test1.sh is failing because it's not working.
** TODO tagfs fsck: measure space amplification
count the amount by which extent list sizes exceed i_size
If verbose, list each file that has (-v) over 2MiB of space amp (-vv) any space amp at all
** TODO tagfs fsck should check for non-DAX files
This would be files that were not created through the proper procedure. Need to figure out
the right way to do this.
** DONE tagfs getmap
Dump the file map, optionally in the form of a command line that can be used to create a
clone of the file. The dump works, but not in command line format.
-> decided to drop the "prescriptve creat" in favor of clone. So this can be marked done..
** DONE tagfs cp
Copy a file to tagfs. Source can be in tagfs, or separate. This requires the allocator.
Basically working, but not fully tested
** DONE tagfs creat
** DONE tagfs clone
Create a second file referenceing the same memory. This is for testing - two files referencing
the same data will cause errors from fsck.

This should be a command that only works if you set a "testing" option (TBD)
** TODO tagfs setmode


* 7/21 debugging files > 1 page
Mission accomplished...
** iomap_begin()
*** xfs iomap begin funcs that call xfs_bmbt_to_iomapp()
**** xfs_direct_write_iomap_begin()
**** xfs_buffered_write_iomap_begin()
This one is complicated due to delayed allocations
**** xfs_read_iomap_begin()
**** xfs_seek_iomap_begin()
**** xfs_xattr_iomap_begin()



* Page fault debug plan

* Notes on mmap / fault code flow

* current bug 
** Intended breakpoints

Num Type       Disp Enb Addr               Hits What
1   breakpoint keep y   <PENDING>          1    tagfs_iomap_begin
2   breakpoint keep y   0xffffffffa0941b60 1    in tagfs_iomap_begin of /home/jmg/w/tagfs/tagfs/tagfs_file.c:326
3   breakpoint keep y   <PENDING>          2    tagfs_file_create
4   breakpoint keep y   <PENDING>          2    tagfs_file_mmap
5   breakpoint keep y   0xffffffff814e8540 1    in dax_iomap_fault of fs/dax.c:1934
6   breakpoint keep y   <PENDING>          0    tagfs_filemap_huge_fault
7   breakpoint keep y   <PENDING>          0    tagfs_filemap_fault
8   breakpoint keep y   <PENDING>          0    tagfs_dax_fault

** Notes
dax_iomap_fault()
  PE_SIZE_PMD -> dax_iomap_pmd_fault()
    dax_fault_check_fallback -> fallback to pte fault (4K)

mmap.c/mmap_region()
   tagfs_file_mmap()

tagfs_filemap_huge_fault()
    (?) tagfs_filemap_fault()
        __tagfs_filemap_fault()
	    dax_iomap_fault(PMD) ->FALLBACK
	        tagfs_filemap_fault(PTE)
		   __tagfs_filemap_fault(PTE)
2		       dax_iomap_fault(PTE)
		           dax_iomap_pte_fault()
			       iomap_iter()
			           iomap_iter_advance() #resets iomap and srcmap
			       dax_fault_iter() - HORKAGE

dax_iomap_fault()
    dax_iomap_pte_fault()
        grab_mapping_entry() // gets xarray for page cache (former radix tree)
        while(iomap_iter() > 0) // while not error
	        iomap_iter: if iter->iomap.length: ops->iomap_end()
		iomap_iter: iomap_advance()
		iomap_iter: ops->iomap_begin()
		iomap_titer: iomap_done()
	    xfs_direct_write_iomap_begin() (iomap->begin())
	    dax_fault_iter
	        iomap_direct_access() (returns kaddr)
	    if (!error) iter->processed = PAGE_SIZE
			       
# as initialized by iomap_iter
(gdb) p *iter
$5 = {inode = 0xffff8880103f0a00,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,  /* IOMAP_WRITE IOMAP_FAULT IOMAP_DAX */
    iomap = {addr = 0,
        offset = 0, length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    private = 0x0 <fixed_percpu_data>}

# tagfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff888010510280,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,  /* This seems like a problem! */
        offset = 6291456,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880050263c0,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }
    
# xfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff88801028a138,
    pos = 3538944,
    len = 131072,
    processed = 0,
    flags = 9,
    iomap = {
        addr = 1334812672,
        offset = 4096,
	length = 4845568,
	type = 2,
	flags = 2,               /* IOMAP_F_DIRTY - difference probably insignificant */x
	bdev = 0xffff888007299900,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03ed420 <xfs_iomap_folio_ops>,
	validity_cookie = 10
    },
    srcmap = {
        addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }




# xfs before
(gdb) p *iter
$1 = {
inode = 0xffff8880253cfd38, pos = 0, len = 4096, processed = 0, flags = 265, iomap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, srcmap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, private = 0x0 <fixed_percpu_data>}
(gdb) p *iter
$2 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
    addr = 0,
    offset = 0,
    length = 0,
    type = 0,
    flags = 0,
    bdev = 0x0 <fixed_percpu_data>,
    dax_dev = 0x0 <fixed_percpu_data>,
    inline_data = 0x0 <fixed_percpu_data>,
    private = 0x0 <fixed_percpu_data>,
    folio_ops = 0x0 <fixed_percpu_data>,
    validity_cookie = 0},
    private = 0x0 <fixed_percpu_data>
}
# xfs after
(gdb) p *iter
$3 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 4292608,
	offset = 0,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880076f3400,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03f0420,
	validity_cookie = 6
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }

-> dax_insert_entry()

    0  in dax_fault_iter of fs/dax.c:1694
1  in dax_iomap_pte_fault of fs/dax.c:1773
2  in dax_iomap_fault of fs/dax.c:1937
3  in tagfs_dax_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:368
4  in __tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:389
5  in tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:417
6  in __do_fault of mm/memory.c:4155
7  in do_shared_fault of mm/memory.c:4561
8  in do_fault of mm/memory.c:4639
9  in handle_pte_fault of mm/memory.c:4923
10 in __handle_mm_fault of mm/memory.c:5065
11 in handle_mm_fault of mm/memory.c:5211
12 in do_user_addr_fault of arch/x86/mm/fault.c:1407
13 in handle_page_fault of arch/x86/mm/fault.c:1498
14 in exc_page_fault of arch/x86/mm/fault.c:1554
15 in asm_exc_page_fault of ./arch/x86/include/asm/idtentry.h:570
16 in ??

* page sizes
/* page entry size for vm->huge_fault() */
enum page_entry_size {
	PE_SIZE_PTE = 0, /* 4K */
	PE_SIZE_PMD,     /* 2M */
	PE_SIZE_PUD,     /* 1G */
};
