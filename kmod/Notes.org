
TODO

* Semi-working functionality
** tagfs fsck
** mkfs.tagfs <dev>

* char DAX key questions
** How to attach struct dax_operations to struct dax_device
This is done by drivers/nvdimm/pmem.c
** How to get from a daxdev and offset to a kaddr and pfn
Somehow devm_memremap_pages() is invovled


* Testing plans
** DONE test files in non-root directory
and complex paths...
Had to add 'tagfs mkdir', which is now working.
** TODO test filling up a tagfs file system
Need some intelligence to figure out when a create should fail based on size
of the FS.
** TODO Need test that attempts to write past EOF
Should fail to append file past allocation, but succeed *to* allocation
** TODO Need test that overflows the log
** TODO Need test that mounts the same memory/pmem device from mulltiple VMs
...and verifies that they see the same stuff
...and explores whether mutations are immediately visible

* Known bugs
** TODO Char device not cleaned up properly on umount
** TODO the 'tagfs creat' invocations in test0.sh have 000 permissions
...even though that's not the mode they're created under.
But 'tagfs cp' seems to get it right. Should be an easy fix...
** TODO linux "cmp" comparisons fail even when "tagfs verify" succeeds
There is something wrong with posix read. tagfs verify uses mmap, and verifies the
file againsts same-seed data.
** TODO Should flush cache when writing log
This includes initialization as well as writing log entries
** TODO Should invalidate cache prior to reading log
** TODO Should flush cache when writing superblock
** TODO Should invalidate cache prior to reading superblock
Invalidate header and entire log before reading

* Valgrind checking
** DONE tagfs verify
** DONE tagfs mkdir
** DONE tagfs logplay
** DONE tagfs creat
** DONE tagfs cp
** DONE tagfs fsck on fs
** TODO tagfs fsck on device
** TODO tagfs mkmeta
There is a minor leak in tagfs_get_mpt_by_dev() still



* Tests


* Missing functionality
** DONE Tagfs mkdir
Done woohoo
** TODO Tagfs 'mkdir -p' ?
** DONE Create log entry when allocating/creating a file
** DONE play log into file system
'tagfs logplay <mpt>'
** TODO un-tar into file system
** DONE Populate log
** DONE nop ioctl to verify that a file is in a tagfs fs
** TODO mkfs should fail if the device is not larger than the superblock + log
** TODO mkfs should make the log smaller if device is small?
** TODO Need a logplay variant that finds files that don't match logged size

* Needed for testability
** DONE create files of arbitrary sizes
tagfs creat -s <size>
** DONE create files with arbitrary extent lists and warn if extent conflicts
tagfs creat -n 2 --offset 0 --length 0x200000 --offset 0x400000 --length 0x200000
Dropped: clone provides collisions for testability. M

** DONE randomize file content based on supplied key (so files can be verified)
tagfs write -s <seed> -r <file>
** DONE Verify file contents
tagfs verify
** TODO tool to write/read/verify flexibly with both mmap and posix write/read
** TODO Read log and build bitmap, detecting duplicate memory references
** TODO intentional creation of duplicate memory references (alloc with specific extents)

* Add fs parameters
** DONE primary dax dev

* TODO Integrate wtih googletest and automate baseline set of tests
* DONE Debug "tagfs cp" cli functionality
* DONE Need uuid_gen() function in tagfs_lib
* TODO How will the kernel module read/access the superblock and log?
The superblock has the list of dax devices. The primary superblock has the TAGFS_PRIMARY_SB
flag set.

sb->ts_devlist is only valid on the primary superblock.

Each device has a uuid in its superblock - that will be an invariant way to reference
devices. Reference can be by index into teh ts_devlist[] on the primary superblock,
and the tagfs_daxdev needs the uuid for each device.
* TODO Create file ioctl must inherit dax device from superblock (if there is only one)
Oof, this requires a persistent mmap of the superblock and log from the in-memory sb. Hmm.
* DONE generate some proper mmap test cases
* TODO generate proper buffered I/O test cases
* TODO Generate tools for a recursive copy into tagfs file system
* DONE top level makefile that builds everything
* TODO Debug accessing dax device without block device
* TODO Study what happens when tagfs file is "of" for dd
The file gets truncated to zero-length, but then no writing happens

* DONE Rename ioctl #defines (s/MCIOC/TAGFSIOC/)

* DONE Superblock needs a UUID
* TODO Each file creation log entry needs a UUID (i.e. a file UUID)

* Design and implement MVP allocator
** DONE Generate a hidden allocation log file
Format: superblock, allocation log, superblock crc
Superblock: magic #, format version, offset to start of log, offset to next free log space
Each log entry: relpath, ext list, size, crc
Log entry types: file allocation, host access

* Test coverage


** interesting Idea:
*** Append-only allocation log
Only used by owner; can make allocations durable long before files get committed.
And allocations can be freed prior to file commit.

Issue: can I guarantee freeing of space for uncommitted files? If files have UUIDs and
allocation entries reference the file UUID, we can scan the main log and the allocation log and
free any allocations that reference UUIDs that are not assoociated with files. File creation
would have to be totally embargoed during this process.

*** Main log gets file creation entries when committed


** DONE Scan log and create allocation bitmap
All allocations work this way now (except the explicit ones via tagfs creat)
** TODO Scan all files and create allocation bitmap
Do this by scanning files rather than scanning log. Maybe even compare to log-based
bitmap

* Kernel fs features
** DONE decouple size from extent list
i.e. size can be <= extent list length
** DONE Dump the user-space file metadata (for cloning)
This will return a tagfs_ioc_map and an array of tagfs_user_extent structs
(might be 2 ioctls, one for tagfs_ioc_map - which will indicate how many extents - and a
second for the array of extents)
Have clone now, and have getmap. Calling this done.
** TODO dump the xarray of which pages are currently populated
This is a derivative of csnoop, though the xarray conversion may change it.

* libtagfs
** TODO tagfs_create
- Create file in <mount_pt>/.tmp
- Set allocation and file size
- Mv to intended path
** DONE get size of pmem block device
** TODO Get size of dax character device
Done but need to test
** TODO Get device size regardless of type
Done but char device not tested yet
** TODO tagfs_setmode
** DONE tagfs_clone
Create another file referencing the same data. This should cause an fsck error, because
fsck will notice allocated blocks that are referenced by more than one file.

* Tagfs cli
** DONE tagfs fsck: check for double allocations and return err if there are errs
This can be marked done when there is a test.
This was working, but now test1.sh is failing because it's not working.
(the issue was related to acessing the log & superblock via the pmem device vs. via the
.superblock and .log files. Now I only allow using the files while the FS is mounted, and
it works.)
** DONE tagfs fsck: measure space amplification

count the amount by which extent list sizes exceed i_size
If verbose, list each file that has (-v) over 2MiB of space amp (-vv) any space amp at all
** TODO tagfs fsck should check for non-DAX files
This would be files that were not created through the proper procedure. Need to figure out
the right way to do this.
** DONE tagfs getmap
Dump the file map, optionally in the form of a command line that can be used to create a
clone of the file. The dump works, but not in command line format.
-> decided to drop the "prescriptve creat" in favor of clone. So this can be marked done..
** DONE tagfs cp
Copy a file to tagfs. Source can be in tagfs, or separate. This requires the allocator.
Basically working, but not fully tested
** DONE tagfs creat
** DONE tagfs clone
Create a second file referenceing the same memory. This is for testing - two files referencing
the same data will cause errors from fsck.

This should be a command that only works if you set a "testing" option (TBD)
** TODO tagfs setmode


* Page fault debug plan

* Notes on mmap / fault code flow

* current bug (fixed)
** Intended breakpoints

Num Type       Disp Enb Addr               Hits What
1   breakpoint keep y   <PENDING>          1    tagfs_iomap_begin
2   breakpoint keep y   0xffffffffa0941b60 1    in tagfs_iomap_begin of /home/jmg/w/tagfs/tagfs/tagfs_file.c:326
3   breakpoint keep y   <PENDING>          2    tagfs_file_create
4   breakpoint keep y   <PENDING>          2    tagfs_file_mmap
5   breakpoint keep y   0xffffffff814e8540 1    in dax_iomap_fault of fs/dax.c:1934
6   breakpoint keep y   <PENDING>          0    tagfs_filemap_huge_fault
7   breakpoint keep y   <PENDING>          0    tagfs_filemap_fault
8   breakpoint keep y   <PENDING>          0    tagfs_dax_fault

** Notes
dax_iomap_fault()
  PE_SIZE_PMD -> dax_iomap_pmd_fault()
    dax_fault_check_fallback -> fallback to pte fault (4K)

mmap.c/mmap_region()
   tagfs_file_mmap()

tagfs_filemap_huge_fault()
    (?) tagfs_filemap_fault()
        __tagfs_filemap_fault()
	    dax_iomap_fault(PMD) ->FALLBACK
	        tagfs_filemap_fault(PTE)
		   __tagfs_filemap_fault(PTE)
2		       dax_iomap_fault(PTE)
		           dax_iomap_pte_fault()
			       iomap_iter()
			           iomap_iter_advance() #resets iomap and srcmap
				   iomap->begin() /* gets struct dax_device, offset, len */
			       dax_fault_iter() - HORKAGE

dax_iomap_fault()
    dax_iomap_pte_fault()
        grab_mapping_entry() // gets xarray for page cache (former radix tree)
        while(iomap_iter() > 0) // while not error
	        iomap_iter: if iter->iomap.length: ops->iomap_end()
		iomap_iter: iomap_advance()
		iomap_iter: ops->iomap_begin()
		iomap_iter: iomap_done()
	    xfs_direct_write_iomap_begin() (iomap->begin())
	    dax_fault_iter
	        iomap_direct_access() (returns kaddr)
	    if (!error) iter->processed = PAGE_SIZE
			       
# as initialized by iomap_iter
(gdb) p *iter
$5 = {inode = 0xffff8880103f0a00,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,  /* IOMAP_WRITE IOMAP_FAULT IOMAP_DAX */
    iomap = {addr = 0,
        offset = 0, length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    private = 0x0 <fixed_percpu_data>}

# tagfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff888010510280,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,  /* This seems like a problem! */
        offset = 6291456,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880050263c0,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }
    
# xfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff88801028a138,
    pos = 3538944,
    len = 131072,
    processed = 0,
    flags = 9,
    iomap = {
        addr = 1334812672,
        offset = 4096,
	length = 4845568,
	type = 2,
	flags = 2,               /* IOMAP_F_DIRTY - difference probably insignificant */x
	bdev = 0xffff888007299900,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03ed420 <xfs_iomap_folio_ops>,
	validity_cookie = 10
    },
    srcmap = {
        addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }




# xfs before
(gdb) p *iter
$1 = {
inode = 0xffff8880253cfd38, pos = 0, len = 4096, processed = 0, flags = 265, iomap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, srcmap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, private = 0x0 <fixed_percpu_data>}
(gdb) p *iter
$2 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
    addr = 0,
    offset = 0,
    length = 0,
    type = 0,
    flags = 0,
    bdev = 0x0 <fixed_percpu_data>,
    dax_dev = 0x0 <fixed_percpu_data>,
    inline_data = 0x0 <fixed_percpu_data>,
    private = 0x0 <fixed_percpu_data>,
    folio_ops = 0x0 <fixed_percpu_data>,
    validity_cookie = 0},
    private = 0x0 <fixed_percpu_data>
}
# xfs after
(gdb) p *iter
$3 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 4292608,
	offset = 0,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880076f3400,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03f0420,
	validity_cookie = 6
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }

-> dax_insert_entry()

    0  in dax_fault_iter of fs/dax.c:1694
1  in dax_iomap_pte_fault of fs/dax.c:1773
2  in dax_iomap_fault of fs/dax.c:1937
3  in tagfs_dax_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:368
4  in __tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:389
5  in tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:417
6  in __do_fault of mm/memory.c:4155
7  in do_shared_fault of mm/memory.c:4561
8  in do_fault of mm/memory.c:4639
9  in handle_pte_fault of mm/memory.c:4923
10 in __handle_mm_fault of mm/memory.c:5065
11 in handle_mm_fault of mm/memory.c:5211
12 in do_user_addr_fault of arch/x86/mm/fault.c:1407
13 in handle_page_fault of arch/x86/mm/fault.c:1498
14 in exc_page_fault of arch/x86/mm/fault.c:1554
15 in asm_exc_page_fault of ./arch/x86/include/asm/idtentry.h:570
16 in ??

* page sizes
/* page entry size for vm->huge_fault() */
enum page_entry_size {
	PE_SIZE_PTE = 0, /* 4K */
	PE_SIZE_PMD,     /* 2M */
	PE_SIZE_PUD,     /* 1G */
};

* debugging character dax

** char bug 8/17

Can load module, mkfs, mount in char mode via char_test0.sh script
Then unload (teardown.sh script)
Then run char_test0.sh script again and this happens:

Aug 17 08:43:25 dev1 kernel: tagfs_exit
Aug 17 08:43:25 dev1 kernel: tagfs_exit: unregistered
Aug 17 08:43:28 dev1 kernel: BUG: kernel NULL pointer dereference, address: 0000000000000008
Aug 17 08:43:28 dev1 kernel: #PF: supervisor read access in kernel mode
Aug 17 08:43:28 dev1 kernel: #PF: error_code(0x0000) - not-present page
Aug 17 08:43:28 dev1 kernel: PGD 800000000e68d067 P4D 800000000e68d067 PUD e698067 PMD 0 
Aug 17 08:43:28 dev1 kernel: Oops: 0000 [#1] PREEMPT SMP PTI
Aug 17 08:43:28 dev1 kernel: CPU: 1 PID: 1083 Comm: mkfs.tagfs Tainted: G           OE      6.3.1-cxl4+ #23
Aug 17 08:43:28 dev1 kernel: Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014
Aug 17 08:43:28 dev1 kernel: RIP: 0010:check_vma+0x1a/0x160 [device_dax]
Aug 17 08:43:28 dev1 kernel: Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 e5 41 56 4c 8d 77 30 41 55 49 89 d5 41 54 49 89 fc 53 <48> 8b 7f 08 48 89 f3 e8 da 24 15 e1 84 c0 0f 84 d7 00 00 00 f6 43
Aug 17 08:43:28 dev1 kernel: RSP: 0018:ffffc90000e17c00 EFLAGS: 00010282
Aug 17 08:43:28 dev1 kernel: RAX: 0000000000000000 RBX: ffff888033a15098 RCX: 0000000000000000
Aug 17 08:43:28 dev1 kernel: RDX: ffffffffa09f3158 RSI: ffff888033a15098 RDI: 0000000000000000
Aug 17 08:43:28 dev1 kernel: RBP: ffffc90000e17c20 R08: ffffc90000e17bf8 R09: 0000000000000000
Aug 17 08:43:28 dev1 kernel: R10: ffff888033a15098 R11: ffff88800e10300c R12: 0000000000000000
Aug 17 08:43:28 dev1 kernel: R13: ffffffffa09f3158 R14: 0000000000000030 R15: 0000000000000008
Aug 17 08:43:28 dev1 kernel: FS:  00007f4101ee4780(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000
Aug 17 08:43:28 dev1 kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
Aug 17 08:43:28 dev1 kernel: CR2: 0000000000000008 CR3: 000000000e5ce002 CR4: 0000000000170ee0
Aug 17 08:43:28 dev1 kernel: Call Trace:
Aug 17 08:43:28 dev1 kernel:  <TASK>
Aug 17 08:43:28 dev1 kernel:  dax_mmap+0x34/0xa0 [device_dax]
Aug 17 08:43:28 dev1 kernel:  mmap_region+0x237/0x8f0
Aug 17 08:43:28 dev1 kernel:  do_mmap+0x355/0x5d0
Aug 17 08:43:28 dev1 kernel:  vm_mmap_pgoff+0xdd/0x180
Aug 17 08:43:28 dev1 kernel:  ksys_mmap_pgoff+0x190/0x200
Aug 17 08:43:28 dev1 kernel:  __x64_sys_mmap+0x33/0x50
Aug 17 08:43:28 dev1 kernel:  do_syscall_64+0x5c/0x90
Aug 17 08:43:28 dev1 kernel:  ? syscall_exit_to_user_mode+0x1b/0x40
Aug 17 08:43:28 dev1 kernel:  ? do_syscall_64+0x68/0x90
Aug 17 08:43:28 dev1 kernel:  ? switch_fpu_return+0x61/0xf0
Aug 17 08:43:28 dev1 kernel:  ? exit_to_user_mode_prepare+0x145/0x200
Aug 17 08:43:28 dev1 kernel:  ? syscall_exit_to_user_mode+0x1b/0x40
Aug 17 08:43:28 dev1 kernel:  ? do_syscall_64+0x68/0x90
Aug 17 08:43:28 dev1 kernel:  entry_SYSCALL_64_after_hwframe+0x72/0xdc
Aug 17 08:43:28 dev1 kernel: RIP: 0033:0x7f4101ff1ed7
Aug 17 08:43:28 dev1 kernel: Code: 44 00 00 44 89 e7 e8 78 b2 ff ff eb e6 e8 31 7c 01 00 90 f3 0f 1e fa 41 89 ca 41 f7 c1 ff 0f 00 00 75 10 b8 09 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 21 c3 48 8b 05 01 9f 0c 00 64 c7 00 16 00 00
Aug 17 08:43:28 dev1 kernel: RSP: 002b:00007ffdf1445188 EFLAGS: 00000246 ORIG_RAX: 0000000000000009
Aug 17 08:43:28 dev1 kernel: RAX: ffffffffffffffda RBX: 00007ffdf1445358 RCX: 00007f4101ff1ed7
Aug 17 08:43:28 dev1 kernel: RDX: 0000000000000003 RSI: 0000000000a00000 RDI: 0000000000000000
Aug 17 08:43:28 dev1 kernel: RBP: 00007ffdf14451d0 R08: 0000000000000003 R09: 0000000000000000
Aug 17 08:43:28 dev1 kernel: R10: 0000000000000001 R11: 0000000000000246 R12: 0000000000000004
Aug 17 08:43:28 dev1 kernel: R13: 0000000000000000 R14: 00007f410210f000 R15: 0000000000409df0
Aug 17 08:43:28 dev1 kernel:  </TASK>
Aug 17 08:43:28 dev1 kernel: Modules linked in: kmem device_dax rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 intel_rapl_msr intel_rapl_common rfkill ip_set kvm_intel snd_hda_codec_generic ledtrig_audio snd_hda_intel nf_tables snd_intel_dspcfg nfnetlink snd_intel_sdw_acpi snd_hda_codec snd_hda_core snd_hwdep snd_seq kvm snd_seq_device iTCO_wdt intel_pmc_bxt snd_pcm qrtr iTCO_vendor_support irqbypass rapl nd_pmem nd_btt dax_pmem pcspkr i2c_i801 snd_timer i2c_smbus snd soundcore lpc_ich virtio_balloon sunrpc joydev fuse loop zram xfs crct10dif_pclmul crc32_pclmul crc32c_intel polyval_clmulni polyval_generic nd_e820 libnvdimm ghash_clmulni_intel sha512_ssse3 virtio_net virtio_gpu net_failover virtio_console virtio_blk failover virtio_dma_buf serio_raw scsi_dh_rdac scsi_dh_emc scsi_dh_alua dm_multipath qemu_fw_cfg
Aug 17 08:43:28 dev1 kernel: Unloaded tainted modules: tagfs(OE):2 [last unloaded: tagfs(OE)]
Aug 17 08:43:28 dev1 kernel: CR2: 0000000000000008
Aug 17 08:43:28 dev1 kernel: ---[ end trace 0000000000000000 ]---
Aug 17 08:43:28 dev1 kernel: RIP: 0010:check_vma+0x1a/0x160 [device_dax]
Aug 17 08:43:28 dev1 kernel: Code: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 0f 1f 44 00 00 55 48 89 e5 41 56 4c 8d 77 30 41 55 49 89 d5 41 54 49 89 fc 53 <48> 8b 7f 08 48 89 f3 e8 da 24 15 e1 84 c0 0f 84 d7 00 00 00 f6 43
Aug 17 08:43:28 dev1 kernel: RSP: 0018:ffffc90000e17c00 EFLAGS: 00010282
Aug 17 08:43:28 dev1 kernel: RAX: 0000000000000000 RBX: ffff888033a15098 RCX: 0000000000000000
Aug 17 08:43:28 dev1 kernel: RDX: ffffffffa09f3158 RSI: ffff888033a15098 RDI: 0000000000000000
Aug 17 08:43:28 dev1 kernel: RBP: ffffc90000e17c20 R08: ffffc90000e17bf8 R09: 0000000000000000
Aug 17 08:43:28 dev1 kernel: R10: ffff888033a15098 R11: ffff88800e10300c R12: 0000000000000000
Aug 17 08:43:28 dev1 kernel: R13: ffffffffa09f3158 R14: 0000000000000030 R15: 0000000000000008
Aug 17 08:43:28 dev1 kernel: FS:  00007f4101ee4780(0000) GS:ffff88807dd00000(0000) knlGS:0000000000000000
Aug 17 08:43:28 dev1 kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
Aug 17 08:43:28 dev1 kernel: CR2: 0000000000000008 CR3: 000000000e5ce002 CR4: 0000000000170ee0
Aug 17 08:44:12 dev1 kernel: clocksource: timekeeping watchdog on CPU0: Marking clocksource 'tsc' as unstable because the skew is too large:
Aug 17 08:44:12 dev1 kernel: clocksource:                       'kvm-clock' wd_nsec: 496037990 wd_now: 23ba2ea641 wd_last: 239c9db5db mask: ffffffffffffffff
Aug 17 08:44:12 dev1 kernel: clocksource:                       'tsc' cs_nsec: 2498943196 cs_now: 5e80395860 cs_last: 5cfcf536b0 mask: ffffffffffffffff
Aug 17 08:44:12 dev1 kernel: clocksource:                       Clocksource 'tsc' skewed 2002905206 ns (2002 ms) over watchdog 'kvm-clock' interval of 496037990 ns (496 ms)
Aug 17 08:44:12 dev1 kernel: clocksource:                       'kvm-clock' (not 'tsc') is current clocksource.
Aug 17 08:44:12 dev1 kernel: tsc: Marking TSC unstable due to clocksource watchdog





** Latest bug 8/16
This happened on umount

Aug 16 17:50:44 dev1 kernel: tagfs_open_char_device: Not a block device; trying character dax
Aug 16 17:50:44 dev1 kernel: tagfs_open_char_device: dax_filp=ffff888009c72e00
Aug 16 17:50:44 dev1 kernel: tagfs_open_char_device: root dev is character dax (/dev/dax0.0) dax_devp (ffff8880067cb740)
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: there are 1 extents
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: superblock
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: ext 0 ofs=0 len=200000
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: offset 0 len 2097152
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: there are 1 extents
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: log
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: ext 0 ofs=200000 len=800000
Aug 16 17:50:44 dev1 kernel: tagfs_file_init_dax: offset 200000 len 8388608
Aug 16 17:52:36 dev1 kernel: ------------[ cut here ]------------
Aug 16 17:52:36 dev1 kernel: kill_dax() must be called before final iput()
Aug 16 17:52:36 dev1 kernel: WARNING: CPU: 0 PID: 14457 at drivers/dax/super.c:376 dax_destroy_inode+0x35/0x40
Aug 16 17:52:36 dev1 kernel: Modules linked in: tagfs(OE) kmem device_dax rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject_ipv6 nft_reject nft_ct nft_chain_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 rfkill ip_set nf_tables nfnetlink qrtr intel_rapl_msr intel_rapl_common sunrpc snd_hda_codec_generic ledtrig_audio kvm_intel snd_hda_intel snd_intel_dspcfg snd_intel_sdw_acpi kvm iTCO_wdt snd_hda_codec intel_pmc_bxt iTCO_vendor_support irqbypass snd_hda_core rapl nd_pmem snd_hwdep nd_btt snd_seq dax_pmem snd_seq_device snd_pcm i2c_i801 snd_timer i2c_smbus pcspkr snd virtio_balloon lpc_ich soundcore joydev fuse loop zram xfs crct10dif_pclmul crc32_pclmul crc32c_intel polyval_clmulni polyval_generic nd_e820 libnvdimm ghash_clmulni_intel sha512_ssse3 virtio_net virtio_gpu virtio_console virtio_blk net_failover failover virtio_dma_buf serio_raw scsi_dh_rdac scsi_dh_emc scsi_dh_alua dm_multipath qemu_fw_cfg
Aug 16 17:52:36 dev1 kernel: Unloaded tainted modules: tagfs(OE):4 [last unloaded: tagfs(OE)]
Aug 16 17:52:36 dev1 kernel: CPU: 0 PID: 14457 Comm: umount Tainted: G        W  OE      6.3.1-cxl4+ #23
Aug 16 17:52:36 dev1 kernel: Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014
Aug 16 17:52:36 dev1 kernel: RIP: 0010:dax_destroy_inode+0x35/0x40
Aug 16 17:52:36 dev1 kernel: Code: 00 a8 01 75 05 c3 cc cc cc cc 80 3d ca 6a 58 01 00 75 f2 55 48 89 e5 c6 05 bd 6a 58 01 01 48 c7 c7 88 0a b3 82 e8 bb e1 5c ff <0f> 0b 5d c3 cc cc cc cc 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90
Aug 16 17:52:36 dev1 kernel: RSP: 0018:ffffc90000acbca8 EFLAGS: 00010282
Aug 16 17:52:36 dev1 kernel: RAX: 0000000000000000 RBX: ffff8880067cb740 RCX: 0000000000000000
Aug 16 17:52:36 dev1 kernel: RDX: 0000000000000002 RSI: ffffffff82ac8e76 RDI: 00000000ffffffff
Aug 16 17:52:36 dev1 kernel: RBP: ffffc90000acbca8 R08: 0000000000000000 R09: ffffc90000acbaf8
Aug 16 17:52:36 dev1 kernel: R10: 0000000000000003 R11: ffffffff82f440a8 R12: ffffffff825d3340
Aug 16 17:52:36 dev1 kernel: R13: ffffffff825d3340 R14: 0000000000000000 R15: 0000000000000000
Aug 16 17:52:36 dev1 kernel: FS:  00007efdf5161800(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000
Aug 16 17:52:36 dev1 kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
Aug 16 17:52:36 dev1 kernel: CR2: 00007f1b0419f74c CR3: 000000000ddce001 CR4: 0000000000170ef0
Aug 16 17:52:36 dev1 kernel: Call Trace:
Aug 16 17:52:36 dev1 kernel:  <TASK>
Aug 16 17:52:36 dev1 kernel:  destroy_inode+0x41/0x80
Aug 16 17:52:36 dev1 kernel:  evict+0x189/0x1d0
Aug 16 17:52:36 dev1 kernel:  iput+0x138/0x230
Aug 16 17:52:36 dev1 kernel:  put_dax+0x13/0x20
Aug 16 17:52:36 dev1 kernel:  fs_put_dax+0x2e/0x50
Aug 16 17:52:36 dev1 kernel:  tagfs_kill_sb+0x51/0x70 [tagfs]
Aug 16 17:52:36 dev1 kernel:  deactivate_locked_super+0x35/0xa0
Aug 16 17:52:36 dev1 kernel:  deactivate_super+0x40/0x50
Aug 16 17:52:36 dev1 kernel:  cleanup_mnt+0xc3/0x160
Aug 16 17:52:36 dev1 kernel:  __cleanup_mnt+0x12/0x20
Aug 16 17:52:36 dev1 kernel:  task_work_run+0x61/0x90
Aug 16 17:52:36 dev1 kernel:  exit_to_user_mode_prepare+0x1ef/0x200
Aug 16 17:52:36 dev1 kernel:  syscall_exit_to_user_mode+0x1b/0x40
Aug 16 17:52:36 dev1 kernel:  do_syscall_64+0x68/0x90
Aug 16 17:52:36 dev1 kernel:  ? syscall_exit_to_user_mode+0x1b/0x40
Aug 16 17:52:36 dev1 kernel:  ? do_syscall_64+0x68/0x90
Aug 16 17:52:36 dev1 kernel:  ? syscall_exit_to_user_mode+0x1b/0x40
Aug 16 17:52:36 dev1 kernel:  ? do_syscall_64+0x68/0x90
Aug 16 17:52:36 dev1 kernel:  ? syscall_exit_to_user_mode+0x1b/0x40
Aug 16 17:52:36 dev1 kernel:  ? do_syscall_64+0x68/0x90
Aug 16 17:52:36 dev1 kernel:  entry_SYSCALL_64_after_hwframe+0x72/0xdc
Aug 16 17:52:36 dev1 kernel: RIP: 0033:0x7efdf537878b
Aug 16 17:52:36 dev1 kernel: Code: c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 f3 0f 1e fa 31 f6 e9 05 00 00 00 0f 1f 44 00 00 f3 0f 1e fa b8 a6 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 05 c3 0f 1f 40 00 48 8b 15 49 16 0c 00 f7 d8
Aug 16 17:52:36 dev1 kernel: RSP: 002b:00007fff7b9909f8 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6
Aug 16 17:52:36 dev1 kernel: RAX: 0000000000000000 RBX: 000055d5cbd926a0 RCX: 00007efdf537878b
Aug 16 17:52:36 dev1 kernel: RDX: 0000000000000000 RSI: 0000000000000000 RDI: 000055d5cbd97fd0
Aug 16 17:52:36 dev1 kernel: RBP: 00007fff7b990ad0 R08: 0000000000000020 R09: 0000000000000001
Aug 16 17:52:36 dev1 kernel: R10: 0000000000000004 R11: 0000000000000246 R12: 000055d5cbd927b8
Aug 16 17:52:36 dev1 kernel: R13: 0000000000000000 R14: 000055d5cbd97fd0 R15: 000055d5cbd928d0
Aug 16 17:52:36 dev1 kernel:  </TASK>
Aug 16 17:52:36 dev1 kernel: ---[ end trace 0000000000000000 ]---
Aug 16 17:52:36 dev1 kernel: tagfs_exit
Aug 16 17:52:36 dev1 kernel: tagfs_exit: unregistered




** Working notes

*** Alternate strategy: wrap dax mmap, and hack memcpy
**** tagfs_mmap() calls dax_mmap()
Problem: if the file is not contiguous, we won't be able to map more than one ext at a time
But: Currently files only have one extent.

**** tagfs_dax_rw()



*** The pmem strategy: Using iomap for rw/mmap of char dax device
Pro: would work just like /dev/pmem fsdax
Con: currently requires a kernel patch
The iomap handlers don't work (simplest failure cause) because in a char dax device,
'struct dax_device' has a NULL 'struct dax_operations'

drivers/dax/bus.c has this comment:
         * No dax_operations since there is no access to this device outside of
	 * mmap of the resulting character device.

**** Copying to dax mem

mem = kmap_atomic(struct page) // the source memory
memcopy_flushcache(pmem_addr, mem + offset_into_page, size)
kunmap_atomic(page)

The pmem is always assumed to be contiguous

*** Notes on drivers/dax vm_operations
**** dev_dax->align is the pagesize/alignment required
**** has a vm_operation "pagesize"
...which apears to support both 2MiB and 1GiB
**** also has a "may_split" vm_operation
which returns NULL or -EINVAL

*** Notes on dax_mmap() & fault handlers from drivers/dax/device.c

**** fault handlers call dax_pgoff_to_phys()
         pgoff = linear_page_index(vmf->vma, pmd_addr);
         phys = dax_pgoff_to_phys(dev_dax, pgoff, PMD_SIZE);
         if (phys == -1) {
                 dev_dbg(dev, "pgoff_to_phys(%#lx) failed\n", pgoff);
                 return VM_FAULT_SIGBUS;
         }
 
         pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
 
         dax_set_mapping(vmf, pfn, fault_size);
 
         return vmf_insert_pfn_pmd(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);

