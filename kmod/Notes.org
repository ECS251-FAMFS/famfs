
TODO

* Semi-working functionality
** tagfs fsck
** mkfs.tagfs <dev>

* Testing plans
** DONE test files in non-root directory
and complex paths...
Had to add 'tagfs mkdir', which is now working.
** TODO test filling up a tagfs file system
Need some intelligence to figure out when a create should fail based on size
of the FS.
** TODO Need test that attempts to write past EOF
Should fail to append file past allocation, but succeed *to* allocation
** TODO Need test that overflows the log
** TODO Need test that mounts the same memory/pmem device from mulltiple VMs
...and verifies that they see the same stuff
...and explores whether mutations are immediately visible

* Known bugs
** DONE tagfs logplay: if relpath contains subdir, it gets created as a file
** TODO the 'tagfs creat' invocations in test0.sh have 000 permissions
...even though that's not the mode they're created under.
But 'tagfs cp' seems to get it right. Should be an easy fix...
** TODO linux "cmp" comparisons fail even when "tagfs verify" succeeds
There is something wrong with posix read. tagfs verify uses mmap, and verifies the
file againsts same-seed data.
** DONE tagfs fsck: should fail by dev when mounted
Should be able to accomplish this via exclusive open in the driver...?
Fixed in tagfs_lib.c:tagfs_fsck, which new checks if mounted if invoked
by device.
** DONE tagfs fsck: sees empty log via /dev/pmem0
This worries me a bit. tagfs logplay via the file interface sees log entries, but
when the log is mmapped via /dev/pmem0, the log looks legit but empty. WTF?!
OK: this behavior happens when the file system is mounted and the log gets accessed
via the pmem device rather than the log file. Yeah, same memory, differnet method and
result. Solution: don't allow fsck via blkdev while the FS is mounted (which is a normal
limitation)
** DONE fsck via the meta files (rather than via pmem device) segfaults
If pass in a mount point or tagfs path, fsck now finds the meta files, but it
segfaults when checking the superblock magic #, even though in gdb I can dup the
contents of the superblock. Weird...
Solution: for some reason this didn't work via mmap (segfault when dereferencing
sb-> or logp-> even though gdb could dereference them. But allocating space and doing
a posix read into it solves that problem.
** DONE tagfs creat: manually creating a cross-linked-file fails
File has no extents, is 0 size, and does not get unlinked
see test_corruption0.sh
Dropped manual extents. Just use clone instead.
** DONE tagfs creat: extents out of order when creating with manual extents
When I create a zero-based extent followed by a non-zero-based extent, I see them
out of order in getmap
Moot now that manual extents are dropped. (use clone instead)
** DONE tagfs fsck: does not detect cloned files
Now it returns the error count
Hmm: I saw it work, but it's failing with the current test2.sh.
Answer: that was almost certainly because fsck accessed /dev/pmem0 while the FS
was mounted, which somehow saw a stale log.
** DONE tagfs creat: mode is all 000
Looks like the mode string passed into open/creat is not 000

* Valgrind checking
** DONE tagfs verify
** DONE tagfs mkdir
** DONE tagfs logplay
** DONE tagfs creat
** DONE tagfs cp
** DONE tagfs fsck on fs
** TODO tagfs fsck on device
** TODO tagfs mkmeta
There is a minor leak in tagfs_get_mpt_by_dev() still



* Tests


* Missing functionality
** DONE Tagfs mkdir
Done woohoo
** TODO Tagfs 'mkdir -p' ?
** DONE Create log entry when allocating/creating a file
** DONE play log into file system
'tagfs logplay <mpt>'
** TODO un-tar into file system
** DONE Populate log
** DONE nop ioctl to verify that a file is in a tagfs fs
** TODO mkfs should fail if the device is not larger than the superblock + log
** TODO mkfs should make the log smaller if device is small?
** TODO Need a logplay variant that finds files that don't match logged size

* Needed for testability
** DONE create files of arbitrary sizes
tagfs creat -s <size>
** DONE create files with arbitrary extent lists and warn if extent conflicts
tagfs creat -n 2 --offset 0 --length 0x200000 --offset 0x400000 --length 0x200000
Dropped: clone provides collisions for testability. M

** DONE randomize file content based on supplied key (so files can be verified)
tagfs write -s <seed> -r <file>
** DONE Verify file contents
tagfs verify
** TODO tool to write/read/verify flexibly with both mmap and posix write/read
** TODO Read log and build bitmap, detecting duplicate memory references
** TODO intentional creation of duplicate memory references (alloc with specific extents)

* Add fs parameters
** DONE primary dax dev

* TODO Integrate wtih googletest and automate baseline set of tests
* DONE Debug "tagfs cp" cli functionality
* DONE Need uuid_gen() function in tagfs_lib
* TODO How will the kernel module read/access the superblock and log?
The superblock has the list of dax devices. The primary superblock has the TAGFS_PRIMARY_SB
flag set.

sb->ts_devlist is only valid on the primary superblock.

Each device has a uuid in its superblock - that will be an invariant way to reference
devices. Reference can be by index into teh ts_devlist[] on the primary superblock,
and the tagfs_daxdev needs the uuid for each device.
* TODO Create file ioctl must inherit dax device from superblock (if there is only one)
Oof, this requires a persistent mmap of the superblock and log from the in-memory sb. Hmm.
* DONE generate some proper mmap test cases
* TODO generate proper buffered I/O test cases
* TODO Generate tools for a recursive copy into tagfs file system
* DONE top level makefile that builds everything
* TODO Debug accessing dax device without block device
* TODO Study what happens when tagfs file is "of" for dd
The file gets truncated to zero-length, but then no writing happens

* DONE Rename ioctl #defines (s/MCIOC/TAGFSIOC/)

* DONE Superblock needs a UUID
* TODO Each file creation log entry needs a UUID (i.e. a file UUID)

* Design and implement MVP allocator
** DONE Generate a hidden allocation log file
Format: superblock, allocation log, superblock crc
Superblock: magic #, format version, offset to start of log, offset to next free log space
Each log entry: relpath, ext list, size, crc
Log entry types: file allocation, host access

* Test coverage


** interesting Idea:
*** Append-only allocation log
Only used by owner; can make allocations durable long before files get committed.
And allocations can be freed prior to file commit.

Issue: can I guarantee freeing of space for uncommitted files? If files have UUIDs and
allocation entries reference the file UUID, we can scan the main log and the allocation log and
free any allocations that reference UUIDs that are not assoociated with files. File creation
would have to be totally embargoed during this process.

*** Main log gets file creation entries when committed


** DONE Scan log and create allocation bitmap
All allocations work this way now (except the explicit ones via tagfs creat)
** TODO Scan all files and create allocation bitmap
Do this by scanning files rather than scanning log. Maybe even compare to log-based
bitmap

* Kernel fs features
** DONE decouple size from extent list
i.e. size can be <= extent list length
** DONE Dump the user-space file metadata (for cloning)
This will return a tagfs_ioc_map and an array of tagfs_user_extent structs
(might be 2 ioctls, one for tagfs_ioc_map - which will indicate how many extents - and a
second for the array of extents)
Have clone now, and have getmap. Calling this done.
** TODO dump the xarray of which pages are currently populated
This is a derivative of csnoop, though the xarray conversion may change it.

* libtagfs
** TODO tagfs_create
- Create file in <mount_pt>/.tmp
- Set allocation and file size
- Mv to intended path
** DONE get size of pmem block device
** TODO Get size of dax character device
Done but need to test
** TODO Get device size regardless of type
Done but char device not tested yet
** TODO tagfs_setmode
** DONE tagfs_clone
Create another file referencing the same data. This should cause an fsck error, because
fsck will notice allocated blocks that are referenced by more than one file.

* Tagfs cli
** DONE tagfs fsck: check for double allocations and return err if there are errs
This can be marked done when there is a test.
This was working, but now test1.sh is failing because it's not working.
(the issue was related to acessing the log & superblock via the pmem device vs. via the
.superblock and .log files. Now I only allow using the files while the FS is mounted, and
it works.)
** DONE tagfs fsck: measure space amplification
count the amount by which extent list sizes exceed i_size
If verbose, list each file that has (-v) over 2MiB of space amp (-vv) any space amp at all
** TODO tagfs fsck should check for non-DAX files
This would be files that were not created through the proper procedure. Need to figure out
the right way to do this.
** DONE tagfs getmap
Dump the file map, optionally in the form of a command line that can be used to create a
clone of the file. The dump works, but not in command line format.
-> decided to drop the "prescriptve creat" in favor of clone. So this can be marked done..
** DONE tagfs cp
Copy a file to tagfs. Source can be in tagfs, or separate. This requires the allocator.
Basically working, but not fully tested
** DONE tagfs creat
** DONE tagfs clone
Create a second file referenceing the same memory. This is for testing - two files referencing
the same data will cause errors from fsck.

This should be a command that only works if you set a "testing" option (TBD)
** TODO tagfs setmode


* 7/21 debugging files > 1 page
Mission accomplished...
** iomap_begin()
*** xfs iomap begin funcs that call xfs_bmbt_to_iomapp()
**** xfs_direct_write_iomap_begin()
**** xfs_buffered_write_iomap_begin()
This one is complicated due to delayed allocations
**** xfs_read_iomap_begin()
**** xfs_seek_iomap_begin()
**** xfs_xattr_iomap_begin()



* Page fault debug plan

* Notes on mmap / fault code flow

* current bug 
** Intended breakpoints

Num Type       Disp Enb Addr               Hits What
1   breakpoint keep y   <PENDING>          1    tagfs_iomap_begin
2   breakpoint keep y   0xffffffffa0941b60 1    in tagfs_iomap_begin of /home/jmg/w/tagfs/tagfs/tagfs_file.c:326
3   breakpoint keep y   <PENDING>          2    tagfs_file_create
4   breakpoint keep y   <PENDING>          2    tagfs_file_mmap
5   breakpoint keep y   0xffffffff814e8540 1    in dax_iomap_fault of fs/dax.c:1934
6   breakpoint keep y   <PENDING>          0    tagfs_filemap_huge_fault
7   breakpoint keep y   <PENDING>          0    tagfs_filemap_fault
8   breakpoint keep y   <PENDING>          0    tagfs_dax_fault

** Notes
dax_iomap_fault()
  PE_SIZE_PMD -> dax_iomap_pmd_fault()
    dax_fault_check_fallback -> fallback to pte fault (4K)

mmap.c/mmap_region()
   tagfs_file_mmap()

tagfs_filemap_huge_fault()
    (?) tagfs_filemap_fault()
        __tagfs_filemap_fault()
	    dax_iomap_fault(PMD) ->FALLBACK
	        tagfs_filemap_fault(PTE)
		   __tagfs_filemap_fault(PTE)
2		       dax_iomap_fault(PTE)
		           dax_iomap_pte_fault()
			       iomap_iter()
			           iomap_iter_advance() #resets iomap and srcmap
			       dax_fault_iter() - HORKAGE

dax_iomap_fault()
    dax_iomap_pte_fault()
        grab_mapping_entry() // gets xarray for page cache (former radix tree)
        while(iomap_iter() > 0) // while not error
	        iomap_iter: if iter->iomap.length: ops->iomap_end()
		iomap_iter: iomap_advance()
		iomap_iter: ops->iomap_begin()
		iomap_titer: iomap_done()
	    xfs_direct_write_iomap_begin() (iomap->begin())
	    dax_fault_iter
	        iomap_direct_access() (returns kaddr)
	    if (!error) iter->processed = PAGE_SIZE
			       
# as initialized by iomap_iter
(gdb) p *iter
$5 = {inode = 0xffff8880103f0a00,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,  /* IOMAP_WRITE IOMAP_FAULT IOMAP_DAX */
    iomap = {addr = 0,
        offset = 0, length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    private = 0x0 <fixed_percpu_data>}

# tagfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff888010510280,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,  /* This seems like a problem! */
        offset = 6291456,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880050263c0,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }
    
# xfs after iomap_begin:
(gdb) p *iter
$1 = {inode = 0xffff88801028a138,
    pos = 3538944,
    len = 131072,
    processed = 0,
    flags = 9,
    iomap = {
        addr = 1334812672,
        offset = 4096,
	length = 4845568,
	type = 2,
	flags = 2,               /* IOMAP_F_DIRTY - difference probably insignificant */x
	bdev = 0xffff888007299900,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03ed420 <xfs_iomap_folio_ops>,
	validity_cookie = 10
    },
    srcmap = {
        addr = 0,
        offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }




# xfs before
(gdb) p *iter
$1 = {
inode = 0xffff8880253cfd38, pos = 0, len = 4096, processed = 0, flags = 265, iomap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, srcmap = {addr = 0, offset = 0, length = 0, type = 0, flags = 0, bdev = 0x0 <fixed_percpu_data>, dax_dev = 0x0 <fixed_percpu_data>, inline_data = 0x0 <fixed_percpu_data>, private = 0x0 <fixed_percpu_data>, folio_ops = 0x0 <fixed_percpu_data>, validity_cookie = 0}, private = 0x0 <fixed_percpu_data>}
(gdb) p *iter
$2 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0
    },
    srcmap = {
    addr = 0,
    offset = 0,
    length = 0,
    type = 0,
    flags = 0,
    bdev = 0x0 <fixed_percpu_data>,
    dax_dev = 0x0 <fixed_percpu_data>,
    inline_data = 0x0 <fixed_percpu_data>,
    private = 0x0 <fixed_percpu_data>,
    folio_ops = 0x0 <fixed_percpu_data>,
    validity_cookie = 0},
    private = 0x0 <fixed_percpu_data>
}
# xfs after
(gdb) p *iter
$3 = {
    inode = 0xffff8880103ab538,
    pos = 0,
    len = 4096,
    processed = 0,
    flags = 265,
    iomap = {
        addr = 4292608,
	offset = 0,
	length = 4096,
	type = 2,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0xffff8880076f3400,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0xffffffffa03f0420,
	validity_cookie = 6
    },
    srcmap = {
        addr = 0,
	offset = 0,
	length = 0,
	type = 0,
	flags = 0,
	bdev = 0x0 <fixed_percpu_data>,
	dax_dev = 0x0 <fixed_percpu_data>,
	inline_data = 0x0 <fixed_percpu_data>,
	private = 0x0 <fixed_percpu_data>,
	folio_ops = 0x0 <fixed_percpu_data>,
	validity_cookie = 0},
	private = 0x0 <fixed_percpu_data>
    }

-> dax_insert_entry()

    0  in dax_fault_iter of fs/dax.c:1694
1  in dax_iomap_pte_fault of fs/dax.c:1773
2  in dax_iomap_fault of fs/dax.c:1937
3  in tagfs_dax_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:368
4  in __tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:389
5  in tagfs_filemap_fault of /home/jmg/w/tagfs/tagfs/tagfs_file.c:417
6  in __do_fault of mm/memory.c:4155
7  in do_shared_fault of mm/memory.c:4561
8  in do_fault of mm/memory.c:4639
9  in handle_pte_fault of mm/memory.c:4923
10 in __handle_mm_fault of mm/memory.c:5065
11 in handle_mm_fault of mm/memory.c:5211
12 in do_user_addr_fault of arch/x86/mm/fault.c:1407
13 in handle_page_fault of arch/x86/mm/fault.c:1498
14 in exc_page_fault of arch/x86/mm/fault.c:1554
15 in asm_exc_page_fault of ./arch/x86/include/asm/idtentry.h:570
16 in ??

* page sizes
/* page entry size for vm->huge_fault() */
enum page_entry_size {
	PE_SIZE_PTE = 0, /* 4K */
	PE_SIZE_PMD,     /* 2M */
	PE_SIZE_PUD,     /* 1G */
};

* debugging character dax

** First posix read (from logplay)
ul 30 10:57:57 dev1 kernel: tagfs_open_device: Root device is /dev/dax0.0
Jul 30 10:57:57 dev1 kernel: tagfs_open_device: Not a block device; trying character dax
Jul 30 10:57:57 dev1 kernel: tagfs_open_device: dax_filp=ffff88800cda3700
Jul 30 10:57:57 dev1 kernel: tagfs_open_device: root dev is character dax (/dev/dax0.0) dax_devp (ffff888005024340)
Jul 30 10:58:41 dev1 kernel: clocksource: timekeeping watchdog on CPU0: Marking clocksource 'tsc' as unstable because the skew is too large:
Jul 30 10:58:41 dev1 kernel: clocksource:                       'kvm-clock' wd_nsec: 495992656 wd_now: 2a313881043d wd_last: 2a311af0c4ed mask: ffffffffffffffff
Jul 30 10:58:41 dev1 kernel: clocksource:                       'tsc' cs_nsec: 17816562990 cs_now: a2db2714b1 cs_last: 981215ba3f mask: ffffffffffffffff
Jul 30 10:58:41 dev1 kernel: clocksource:                       Clocksource 'tsc' skewed 17320570334 ns (17320 ms) over watchdog 'kvm-clock' interval of 495992656 ns (495 ms)
Jul 30 10:58:41 dev1 kernel: clocksource:                       'kvm-clock' (not 'tsc') is current clocksource.
Jul 30 10:58:41 dev1 kernel: tsc: Marking TSC unstable due to clocksource watchdog
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: there are 1 extents
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: superblock
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: ext 0 ofs=0 len=200000
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: offset 0 len 2097152
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: there are 1 extents
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: log
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: ext 0 ofs=200000 len=800000
Jul 30 11:01:32 dev1 kernel: tagfs_file_init_dax: offset 200000 len 8388608
Jul 30 11:04:14 dev1 kernel: BUG: kernel NULL pointer dereference, address: 0000000000000000
Jul 30 11:04:14 dev1 kernel: #PF: supervisor read access in kernel mode
Jul 30 11:04:14 dev1 kernel: #PF: error_code(0x0000) - not-present page
Jul 30 11:04:14 dev1 kernel: PGD 800000000fad0067 P4D 800000000fad0067 PUD d278067 PMD 0 
Jul 30 11:04:14 dev1 kernel: Oops: 0000 [#1] PREEMPT SMP PTI
Jul 30 11:04:14 dev1 kernel: CPU: 0 PID: 1947 Comm: tagfs Tainted: G           OE      6.3.1-cxl4+ #17
Jul 30 11:04:14 dev1 kernel: Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.2-1.fc38 04/01/2014
Jul 30 11:04:14 dev1 kernel: RIP: 0010:dax_direct_access+0x29/0x80
Jul 30 11:04:14 dev1 kernel: Code: 90 0f 1f 44 00 00 48 85 ff 74 5b 48 8b 87 e8 02 00 00 a8 01 74 32 55 48 89 e5 53 48 89 d3 48 85 d2 78 3a 48 8b 87 f0 02 00 00 <48> 8b 00 e8 bf 8d 4c 00 48 85 c0 74 1d 48 39 c3 48 0f 4e c3>
Jul 30 11:04:14 dev1 kernel: RSP: 0018:ffffc900007bbc28 EFLAGS: 00010206
Jul 30 11:04:14 dev1 kernel: RAX: 0000000000000000 RBX: 0000000000000800 RCX: 0000000000000000
Jul 30 11:04:14 dev1 kernel: RDX: 0000000000000800 RSI: 0000000000000200 RDI: ffff888005024340
Jul 30 11:04:14 dev1 kernel: RBP: ffffc900007bbc30 R08: ffffc900007bbca0 R09: 0000000000000000
Jul 30 11:04:14 dev1 kernel: R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
Jul 30 11:04:14 dev1 kernel: R13: 0000000000000200 R14: 0000000000000000 R15: 0000000000000800
Jul 30 11:04:14 dev1 kernel: FS:  00007f6178e89780(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000
Jul 30 11:04:14 dev1 kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
Jul 30 11:04:14 dev1 kernel: CR2: 0000000000000000 CR3: 000000000b4ea001 CR4: 0000000000170ef0
Jul 30 11:04:14 dev1 kernel: Call Trace:
Jul 30 11:04:14 dev1 kernel:  <TASK>
Jul 30 11:04:14 dev1 kernel:  dax_iomap_rw+0x3ae/0x7a0
Jul 30 11:04:14 dev1 kernel:  ? debug_smp_processor_id+0x17/0x20
Jul 30 11:04:14 dev1 kernel:  tagfs_dax_read_iter+0x34/0x50 [tagfs]
Jul 30 11:04:14 dev1 kernel:  vfs_read+0x23e/0x320
Jul 30 11:04:14 dev1 kernel:  ksys_read+0x73/0xf0
Jul 30 11:04:14 dev1 kernel:  __x64_sys_read+0x19/0x20
Jul 30 11:04:14 dev1 kernel:  do_syscall_64+0x5c/0x90
Jul 30 11:04:14 dev1 kernel:  ? irqentry_exit_to_user_mode+0x9/0x30
Jul 30 11:04:14 dev1 kernel:  ? irqentry_exit+0x3b/0x50
Jul 30 11:04:14 dev1 kernel:  ? exc_page_fault+0x8e/0x190
Jul 30 11:04:14 dev1 kernel:  entry_SYSCALL_64_after_hwframe+0x72/0xdc
Jul 30 11:04:14 dev1 kernel: RIP: 0033:0x7f6178f8d291
Jul 30 11:04:14 dev1 kernel: Code: d5 fe ff ff 55 48 8d 3d 45 55 0a 00 48 89 e5 e8 95 18 02 00 0f 1f 44 00 00 f3 0f 1e fa 80 3d 4d c3 0d 00 00 74 13 31 c0 0f 05 <48> 3d 00 f0 ff ff 77 4f c3 66 0f 1f 44 00 00 55 48 89 e5 48>
Jul 30 11:04:14 dev1 kernel: RSP: 002b:00007ffccefbd3a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000000
Jul 30 11:04:14 dev1 kernel: RAX: ffffffffffffffda RBX: 00007ffccefbe5a8 RCX: 00007f6178f8d291
Jul 30 11:04:14 dev1 kernel: RDX: 0000000000800000 RSI: 00007f6178688010 RDI: 0000000000000003
Jul 30 11:04:14 dev1 kernel: RBP: 00007ffccefbe450 R08: 00000000ffffffff R09: 0000000000000000
Jul 30 11:04:14 dev1 kernel: R10: 00007f6178e9bb28 R11: 0000000000000246 R12: 0000000000000003
Jul 30 11:04:14 dev1 kernel: R13: 0000000000000000 R14: 00007f61790b4000 R15: 000000000040edf0
Jul 30 11:04:14 dev1 kernel:  </TASK>
Jul 30 11:04:14 dev1 kernel: Modules linked in: tagfs(OE) rpcsec_gss_krb5 auth_rpcgss nfsv4 dns_resolver nfs lockd grace fscache netfs nft_fib_inet nft_fib_ipv4 nft_fib_ipv6 nft_fib nft_reject_inet nf_reject_ipv4 nf_reject>
Jul 30 11:04:14 dev1 kernel: CR2: 0000000000000000
Jul 30 11:04:14 dev1 kernel: ---[ end trace 0000000000000000 ]---
Jul 30 11:04:14 dev1 kernel: RIP: 0010:dax_direct_access+0x29/0x80
Jul 30 11:04:14 dev1 kernel: Code: 90 0f 1f 44 00 00 48 85 ff 74 5b 48 8b 87 e8 02 00 00 a8 01 74 32 55 48 89 e5 53 48 89 d3 48 85 d2 78 3a 48 8b 87 f0 02 00 00 <48> 8b 00 e8 bf 8d 4c 00 48 85 c0 74 1d 48 39 c3 48 0f 4e c3>
Jul 30 11:04:14 dev1 kernel: RSP: 0018:ffffc900007bbc28 EFLAGS: 00010206
Jul 30 11:04:14 dev1 kernel: RAX: 0000000000000000 RBX: 0000000000000800 RCX: 0000000000000000
Jul 30 11:04:14 dev1 kernel: RDX: 0000000000000800 RSI: 0000000000000200 RDI: ffff888005024340
Jul 30 11:04:14 dev1 kernel: RBP: ffffc900007bbc30 R08: ffffc900007bbca0 R09: 0000000000000000
Jul 30 11:04:14 dev1 kernel: R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000
Jul 30 11:04:14 dev1 kernel: R13: 0000000000000200 R14: 0000000000000000 R15: 0000000000000800
Jul 30 11:04:14 dev1 kernel: FS:  00007f6178e89780(0000) GS:ffff88807dc00000(0000) knlGS:0000000000000000
Jul 30 11:04:14 dev1 kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
Jul 30 11:04:14 dev1 kernel: CR2: 0000000000000000 CR3: 000000000b4ea001 CR4: 0000000000170ef0

dax_dev->ops is NULL


* Note to Dan Williams

To resume on the fsdax conversation.

First, in the near term I do think there is real value in making it possible to
convert dax dram to a /dev/pmem block device, so that current-generation fsdax
file systems can be created in it. That differs from [tpmfs or ramfs] with
node allocation policies because the file system could be umounted and remounted,
including by a different host (sequential sharing), if that host has access to the
memory device.

Long term, I agree with you that dropping the block device personality makes
sense, homing a shared memory file system directly on the char devices (which will
be "tagged capacity" in the cxl 3 time frame). But right now there are problems with
iomap*() mapping of char dax, so one more reason I lobby for supporting converting
dax dram to block/pmem near term.

I have hacked a version of ramfs that can convert ramfs files into dax files that
map to specified dax memory. This pattern is well established if the device
is /dev/pmem, and I have this working with /dev/pmem. 

But if the device is /dev/dax, there are a bunch of problems that I haven't figured
out yet - and I find no evidence that this has been done yet.

My FS can open the /dev/dax device and get the 'struct dax_device' which is needed
for using iomap* to resolve stuff, but this 'struct dax_device' gets initialized
without a struct dax_operations (which is put there by drivers/nvdimm/pmem.c in
the pmem case) - so it does not work with dax_iomap_rw() and dax_iomap_fault().
My head is hurting at this point, but I'm thinking about adding non-poison-handling
dax_operations to see what blows up next.

A shared "famdisk" file system may have to punt on poison handling (no good
way to distribute that info, but OTH data probably shouldn't live there for long
intervals anyway - undoubtedly a subject for debate), but I'd love to get
this working initially sans poison handling.

Any suggestions? Happy to discuss if this is too arcane for typing



