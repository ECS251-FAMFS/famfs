

TODO Features

* Documentation

** DONE first draft kernel module documentation (to move into Documentation/filesystems/)
** TODO Second draft kmod doc

* Devops Wish List
** Nightly builld in a variety of VM environments
** Nightly coverage tests, keeping a record of coverage over time
** Nightly checkfiles runs, with a record of compliance over time
** Nightly valgrind runs and automation to find failures & make them easy to debug
** Jenkins jobs the check all of the above on pull requests

* Experiments
** Check verbosity of normal operations
*** TODO cp, cp *,
*** TODO mkdir, mkdir -p
*** TODO logplay

* Miscellaeous
** TODO CLI: go through and update usage printouts to be accurate
** DONE Logplay should be quiet unless explicitly verbose
** TODO cp -r: test source trailing slash behavior (compare to native cp -r)
cp -r foo/bar frab should lead frab/bar
cp -r foo/bar/ ... should be the same as cp foo/bar/* ...
** DONE Make building the bitmap lazy in famfs_locked_log? (mkdir doesn't need it)
** DONE cli should have a command to check for bad famfs files
(i.e. files that hvae not been fully daxified, or are not in the log)
Done: "famfs check"
** TODO df does not list famfs mounts
** TODO du does not work with famfs mounts/paths
** DONE Review: make sure no writable opens to SB and log happen until role verified
This is certainly not true yet.
** DONE All log opens; do read-only first, and only open writable on the master
** DONE mkfs should fail if the device is not larger than the superblock + log
Now it fails if dev < 4GiB
** TODO Logplay option: find files that don't match logged size / attributes
** TODO logplay: find and optionally delete files that exist but weren't in the log?
** TODO logplay: fix existing file ownership and permissions to match the log?
** TODO logplay: fix existing file size to match log?
could be an argument --fix
** DONE famfs cp: accept uid/gid/mode args like creat?
** DONE famfs mkdir: accept uid/gid/mode args like creat?
** TODO Illegal: mount famfs over direcory IN a different mount
** TODO when traversing up paths, can we recognize mount point paths?
This would be useful for file system spanning operaitons like mkdir -p
** TODO fsck: some info in the verbose output looks fishy
(negative remainder...)
** TODO File create: allow non-privileged if the user has write perm in the directory?
Log write still requires root. Hmm...
** TODO mkdir: same thing, non-privileged allowed if perms check out on parent dir
** DONE mkdir: plumb verbose
** DONE mkdir: -m -u -g for mode, uid, gid
** DONE mkdir of relpath (relative to cwd) fails even if the path is good
** DONE mkdir -p: test paths like /foo/bar/../../baz/bing
** TODO verify superblock 0444 permissions when opening
** TODO cp -v should print list of files copied
other output should require -vv
** TODO Strip down the output of commands unless -v, -vv etc. are used

* dev_dax support (character device)
Current state: works for mmap but not or read/write
** TODO Char device not cleaned up properly on umount
** TODO get char read/write working

* Processor cache management
Current state: not implemented
** TODO superblock write: flush cache after
** TODO never open superblock writable once it exists
** TODO Log append: use appropriate barriers to guarantee append entry is visible by the time it's detectable
-For SW coherency:
    -  write new log entry
    - flush
    - barrier
    - write log header
    - flush
    (check this work)
** TODO Log play (and read): guarantee that stale cache lines can't be read
-Re-reading log header must be non-temporal, or must invalidate the cache first
-May need invalidate the cache before reading log entries?

* Bugs
** DONE when running logplay manually, first run fails and second run succeeds
Actually this was probably just a malfunction of the new "-v" option (or lack
thereof... still need to fix)
** DONE after big cp -r: lots of alllocation collisions

* Smoke Testing
** DONE logplay -vv -vvv
** DONE fsck: call from non-privileged user (both mmap and not - should fail)
** DONE cp -r: relative and absolute paths
** DONE cp and creat empty file?
** DONE fsck bogus path
** DONE mkdir where there is a parent in the path that is not a dir
** DONE pass negative uid/gid to cli commands
** DONE clone with bogus source
** DONE clone with source not in famfs
** TODO clone where src and dest are in different famfs file systems
Code checks for this, but haven't been testing with more than one dax/pmem device
** DONE Refactor famfs_logplay to be unit testable
** TODO test file and dir creation logging when log is full
** TODO unit: test invalid log entry in build_bitmap
Can be unit tested now, because logplay cann be unit tested
** TODO test bitmap_alloc_contiguous out of space
** TODO Proper test for the log lock preventing bad re-entrancy
** TODO Proper test for logplay --client
** DONE integrate with gcov via cmake
** TODO Need a test that tests wide range of odd file sizes
** DONE Test mkdir -mug
** DONE Test cp -mug
** DONE Test creat -mug
** TODO Need some more stressful automated tests
** TODO Tests that fully validate log behavior
** TODO test filling up a famfs file system
Need some intelligence to figure out when a create should fail based on size
of the FS.
Manual tests now show this behavior is sane.
** TODO Need test that attempts to write past EOF
Should fail to append file past allocation, but succeed *to* allocation
** TODO Need test that overflows the log
Currently difficult because the space will run out before the number of currently-provisioned
log slots runs out. Hmm...
** TODO Good posix I/O test coverage
** TODO init_locked_log on client (will fail)
** TODO init_locked_log when no meta files present
** TODO cause mmap failures (in general)
Difficult, but if size=0, mmap fails. Might use this mock/hack
** DONE famfs_file_create not within famfs
** DONE famfs cp: source is directory (__famfs_cp has untested code here)
(if callers check this, refactor to get rid of untested code)

* Cluster testing
** TODO Need test that mounts the same memory/pmem device from mulltiple VMs
...and verifies that they see the same stuff
...and explores whether mutations are immediately visible

* Performance
** TODO Compare multichase on pmem, /dev/dax, and famfs file

* Wish List
** TODO cli: df
fsck returns useful info, which needs to be reviewed
** TODO un-tar into famfs
** DONE famfs cp -r
Note: cp -r would need a bunch of unit test work; it could easily fill up the log, run the
FS out of space, or both...
** DONE famfs mkdir -p
** TODO Should a log entry be an integer number of cache lines?
It probably won't help...
** TODO famfs mv: rename can work
...but only of logplay looks ahead for renames!!
** TODO Configurable log size?
This would require a bunch of tests
This is complicated, because we use FAMFS_LOG_LEN multiple places
** TODO famfs_mkfile: create in <mpt>/.tmp and then move into place when ready?

* Unit test coverage
** TODO Append log with bad magic number
** TODO Append a log that is full (file creation)
** TODO Append a log that is full (dir creation)
** TODO famfs_relpath_from_fullpath()
pass nonsense mpt and fullpath (mpt is not substring starting at the beginning)
** TODO __open_relpath:
*** TODO get non-blocking flock
*** TODO get non-blocking flock while already holding the lock
*** TODO test the file_not_famfs case (just don't set no_fs_check)
** TODO famfs_fsck - pass in bad path

** TODO The bitmap.h functions (there should be bitmap unit tests to pull in from hse...)
** DONE __open_relpath()
** TODO famfs_get_system_uuid()
** DONE famfs_check_super()
** TODO famfs_get_by_dev()
(requires mocking /proc/mounts)
** TODO famfs_ext_to_simple_ext()
(or maybe git rid of more than one current extent type)
** TODO famfs_validate_log_header
** TODO famfs_log_entry_path_is_relative()
** TODO famfs_validate_log_entry()
** DONE famfs_logplay()
use dry run plus mocking the create functions
** DONE famfs_append_log()
** DONE famfs_log_file_creation()
** TODO famfs_log_dir_creation()
** TODO famfs_map_superblock_by_path()
** TODO famfs_map_log_by_path()
** TODO put_sb_log_into_bitmap()
** TODO famfs_build_bitmap()
** TODO bitmmap_alloc_contiguous()
** DONE __famfs_mkfs

* Functions that can't be readily unit tested
(todo)

* Periodic review
** Unit testable functions
** Non-unit-testable functions
** Re-run valgrind on everything

* Weirdness to study
** TODO Study what happens when famfs file is "of" for dd
The file gets truncated to zero-length, but then no writing happens

* Archives

* Done
** DONE move most of mkfs into famfs_lib.c, so more funcs can be static
** DONE Get tracepoint(s) working so we can verify huge page faults (PMD)
** DONE fix famfs so faults are always (or almost always) 2MiB at a time
This is essential for high performance
** DONE famfs creat: fails with large files (>4G seems to fail)
** DONE Bug: the 'famfs creat' invocations in test0.sh have 000 permissions
...even though that's not the mode they're created under.
But 'famfs cp' seems to get it right. Should be an easy fix...
** DONE linux "cmp" comparisons fail even when "famfs verify" succeeds
There is something wrong with posix read. famfs verify uses mmap, and verifies the
file againsts same-seed data.
** DONE Adapt multichase to test dax and pmem memory
** DONE Adapt multihase to test mmapped file
** DONE Write system uuid to superblock
** DONE libfamfs should prevent log write on system with mismatched uuid
** DONE Use flock spanning alloc, init and log append
** DONE Do an mmap-based logplay for /dev/dax benchmarking
** DONE files on clients should default to read-only
** DONE Add a crc to log entries
** DONE Add a crc to log header
** DONE Logplay: check seq numbers
** DONE Logplay: check crc on entries
** DONE famfs logplay: enforce superblock rules
** DONE famfs_log_append: check host_uuid to see if I'm the master
** DONE (bug) on 1T device, famfs thinks it's full way too soon
Had some regular ints where I needed U64's
** DONE mkfs/famfs_lib: implement superblock crc
(it currently doesn't check the superblock, which is not good)
** DONE famfs fsck: enforce superblock crcb
** DONE famfs fsck: enforce superblock version
** DONE famfs fsck: free space always zero
** DONE famfs fsck: print percentage used
** DONE famfs fsck: optionally print capacities in human form (G)
** DONE files on clients should default to read-only
** DONE test files in non-root directory
and complex paths...
** DONE nop ioctl to verify that a file is in a famfs fs (the __file_not_famfs() func
** DONE famfs fsck: check for double allocations and return err if there are errs
** DONE famfs fsck: measure space amplification
* Get size of dax character device
** DONE get size of pmem block device
** DONE Get device size regardless of type

* Valgrind checking (should repeat periodically with all smoke tests)
** DONE famfs verify
** DONE famfs mkdir
** DONE famfs logplay
** DONE famfs creat
** DONE famfs cp
** DONE famfs fsck on fs
** DONE famfs fsck on device
** DONE famfs mkmeta
** DONE famfs getmap
